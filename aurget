#!/bin/bash
#
# pbrisbin 2013
#
###
AUR='https://aur.archlinux.org'

arguments=()
dependencies=()

# Support {{{
die() { error $*; exit 1; }

info() { echo -e "${colorB}:: $colorW$*$nocolor"; }

warn() { echo -e "${colorY}warning: $nocolor$*" >&2; }

error() { echo -e "${colorR}error: $nocolor$*" >&2; }

debug() {
  $debug && echo -e "$colorW[${colorC}DEBUG$colorW]$nocolor $*" >&2
}

err_no_targets() {
  if [[ "$opmode" == 'upgrade' ]]; then
    echo 'nothing to upgrade'
    exit 0
  fi

  die 'no targets specified (use -h for help)'
}

# thanks Irm
url_encode() {
  echo "$*" \
    | hexdump -v -e '1/1 "%02x\t"' -e '1/1 "%_c\n"' \
    | LANG=C awk '
      $1 == "20"                   { printf("%s", "+"); next }
      $1 ~  /0[adAD]/              {                    next }
      $2 ~  /^[a-zA-Z0-9.*()\/-]$/ { printf("%s", $2);  next }
                                   { printf("%%%s", $1)      }
    '
}

aur_packages_url() {
  echo "$AUR/packages/$(url_encode "${1:0:2}")/$(url_encode "$1")"
}

aur_search_url() {
  echo "$AUR/rpc.php?type=search&arg=$(url_encode "$1")"
}

aur_info_url() {
  echo "$AUR/rpc.php?type=info&arg=$(url_encode "$1")"
}

aur_multiinfo_url() {
  local params='' arg

  for arg; do
    params+="&arg\[\]=$(url_encode "$arg")"
  done

  echo "$AUR/rpc.php?type=multiinfo$params"
}

get() { debug "HTTP GET $colorM$1$nocolor"; curl --silent --fail "$1"; }

pkgbuild() { get "$(aur_packages_url $1)/PKGBUILD"; }

taurball() { get "$(aur_packages_url $1)/${1}.tar.gz"; }

rpc_search() { get "$(aur_search_url "$1")" | parse_rpc; }

rpc_info() { get "$(aur_info_url "$1")" | parse_rpc; }

rpc_multiinfo() { get "$(aur_multiinfo_url "$@")" | parse_rpc; }

parse_rpc() {
  awk -F '[^\\\\]"' -v RS='{"|,"|"}' '
    function unstring(str) {
      sub(/[^:]+:/, "", str)
      gsub(/\\\"/, "\"", str)
      gsub(/"$/, "", str)
      return substr(str, 2, length(str))
    }

    /Name":/        { printf "%s",    unstring($0) }
    /Version":/     { printf "|%s",   unstring($0) }
    /Description":/ { printf "|%s",   unstring($0) }
    /URL":/         { printf "|%s",   unstring($0) }
    /OutOfDate":/   { printf "|%s",   unstring($0) }
    /URLPath":/     { printf "|%s\n", unstring($0) }
  '
}

is_devel() { [[ "$1" =~ -(git|hg|svn|darcs|csv|bzr)$ ]]; }

is_ignored() { [[ " $ignore_packages " =~ " $1 " ]]; }

prompt() {
  local a

  echo -en "$*? [Y/n] "

  $noconfirm && { echo 'Y'; return 0; }

  read a

  case "${a:-y}" in
    y|Y) return 0      ;;
    q|Q) die 'aborted' ;;
    *)   return 1      ;;
  esac
}

prompt_to_edit() {
  local name="$1" pkgbuild="$2"; shift 2
  local action="${*:-sourcing for dependencies}"

  case "${edit_pkgbuilds:-prompt}" in
    never)  return 0 ;;
    prompt) prompt "Edit $name's PKGBUILD before $action" || return 0 ;;
  esac

  $EDITOR "$pkgbuild" || die "editor returned non-zero ($?), aborting"

  prompt "Continue $action"
}

set_defaults() {
  local config_re=' --config +([^ ]+) '

  debug=false
  user_config="${XDG_CONFIG_HOME:-$HOME/.config}/aurgetrc"

  [[ " $* " =~ " --debug " ]] && debug=true
  [[ " $* " =~ $config_re  ]] && user_config="${BASH_REMATCH[1]}"

  build_directory="$PWD"
  devels=false
  discard_sources=true
  ignore_packages=''
  keep_devels=true
  makepkg='makepkg'
  makepkg_options='--syncdeps'
  noconfirm=false
  opmode='install'
  resolve_dependencies=false
  search_mode='search'
  sync_mode='build'
  temp_directory='/tmp/aurget'

  EDITOR="${EDITOR:-$VISUAL}"
  EDITOR="${EDITOR:-vi}"

  colorR="\e[1;31m"
  colorG="\e[1;32m"
  colorY="\e[1;33m"
  colorB="\e[1;34m"
  colorM="\e[1;35m"
  colorC="\e[1;36m"
  colorW="\e[1;37m"
  nocolor="\e[0m"
}

source_config() {
  if [[ -r "$user_config" ]]; then
    debug "sourcing user configuration from $colorM$user_config$nocolor"
    source "$user_config"
  fi
}

set_no_color() {
  colorR=''
  colorG=''
  colorY=''
  colorB=''
  colorM=''
  colorC=''
  colorW=''
  nocolor=''

  makepkg_options+=' --nocolor'
}

parse_options() {
  while [[ -n "$1" ]]; do
    case "$1" in
      -S)            opmode='install'                                ;;
      -Sy)           opmode='install'; sync_mode='install'           ;;
      -Sb)           opmode='install'; sync_mode='build'             ;;
      -Sd)           opmode='install'; sync_mode='download'          ;;
      -Su)           opmode='upgrade'                                ;;
      -Syu|-Suy)     opmode='upgrade'; sync_mode='install'           ;;
      -Sbu|-Sub)     opmode='upgrade'; sync_mode='build'             ;;
      -Sdu|-Sud)     opmode='upgrade'; sync_mode='download'          ;;
      -Ss)           opmode='search' ; search_mode='search'          ;;
      -Ssq|-Sqs)     opmode='search' ; search_mode='quiet'           ;;
      -Si|-Ssi|-Sis) opmode='search' ; search_mode='info'            ;;
      -Sp|-Ssp|-Sps) opmode='search' ; search_mode='print'           ;;
      --ignore)      shift; ignore_packages+=" $1"                   ;;
      --noconfirm)   noconfirm=true; makepkg_options+=" --noconfirm" ;;
      --nocolor)     set_no_color                                    ;;
      --devel)       devels=true                                     ;;
      --deps)        resolve_dependencies=true                       ;;
      --nodeps)      resolve_dependencies=false                      ;;
      --edit)        edit_pkgbuilds='always'                         ;;
      --noedit)      edit_pkgbuilds='never'                          ;;
      --discard)     discard_sources=true                            ;;
      --nodiscard)   discard_sources=false                           ;;
      -h|--help)     message; exit                                   ;;
      --)            shift; arguments+=( "$@" ); return              ;;
      --debug)       :                                               ;;
      --config)      : ; shift                                       ;;
      -*)            warn "unknown option $1, treating as makepkg argument..."
                     makepkg_options+=" $1"                          ;;
      *)             arguments+=( "$1" )                             ;;
    esac

    shift
  done
}

create_temp_directory() {
  debug "storing temporary files in $colorM$temp_directory$nocolor"
  mkdir -p "$temp_directory" || die 'unable to create temp directory'
  rm -rf "$temp_directory"/*
}

enter_build_directory() {
  debug "building in $colorM$build_directory$nocolor"
  mkdir -p "$build_directory" || die 'unable to make build directory'
  cd "$build_directory"       || die 'unable to change to build directory'
}
# }}}

# Search {{{
execute_search() {
  [[ "$opmode" == 'search' ]] || return 1

  debug "executing search for $colorG$@$nocolor (mode: $colorG$search_mode$nocolor)"

  case "$search_mode" in
    search) rpc_search    "$*" | sort | print_search ;;
    info)   rpc_multiinfo "$@" | sort | print_info   ;;
    quiet)  rpc_search    "$*" | sort | cut -d '|' -f 1 ;;
    print)  for name; do pkgbuild "$name"; done ;;
  esac
}

print_search() {
  local name version description outofdate ood

  while IFS='|' read -r name version description _ outofdate _; do
    (( "$outofdate" )) && ood="$colorR[out of date]$nocolor"

    ( echo -e "${colorM}aur/$colorW$name $colorG$version$nocolor $ood"
      echo -e "    ${description//\\\///}"
    ) 2>/dev/null
  done
}

print_info() {
  local name version description url outofdate ood='No'

  while IFS='|' read -r name version description url outofdate _; do
    (( "$outofdate" )) && ood="${colorR}Yes$nocolor"

    ( echo -e "${colorW}Repository  : ${colorM}aur$nocolor"
      echo -e "${colorW}Name        : $name$nocolor"
      echo -e "${colorW}Version     : $colorG$version$nocolor"
      echo -e "${colorW}URL         : $colorC${url//\\\///}$nocolor"
      echo -e "${colorW}Out of date : $nocolor$ood"
      echo -e "${colorW}Description : $nocolor${description//\\\///}\n"
    ) 2>/dev/null
  done
}
# }}}

# Dependency handling {{{
set_dependencies() {
  $resolve_dependencies || return

  info 'Resolving dependencies...'
  create_temp_directory
  resolve "${arguments[@]}"
}

resolve() {
  local name dep

  # global: dependencies[]
  # global: arguments[]

  for name; do
    if source_pkgbuild "$name"; then
      depends=($(pacman -T -- ${depends[@]} ${makedepends[@]}))
      depends=("${depends[@]%>*}")
      depends=("${depends[@]%=*}")
      depends=("${depends[@]%<*}")

      for dep in "${depends[@]}"; do
        resolve "$dep"
      done

      [[ " ${arguments[*]} " =~ " $name " ]] || dependencies+=( "$name" )
    fi
  done
}

source_pkgbuild() {
  local name="$1" pkgbuild="$temp_directory/${1}_PKGBUILD"

  if [[ ! -f "$pkgbuild" ]]; then
    debug "resolving $colorG$name$nocolor (resolved so far: $colorG${#dependencies[@]}$nocolor)"

    if pkgbuild "$name" > "$pkgbuild"; then
      if prompt_to_edit "$name" "$pkgbuild"; then
        debug "sourcing PKGBUILD for $colorG$name$nocolor"
        source "$pkgbuild"
        return 0
      fi
    else
      debug "PKGBUILD ${colorR}not$nocolor available for $colorG$name$nocolor, assuming repository package"
    fi
  fi

  touch "$pkgbuild"
  return 1
}
# }}}

# Available upgrades {{{
add_available_upgrades() {
  [[ "$opmode" == 'upgrade' ]] || return

  info 'Starting AUR upgrade...'
  arguments=( $(available_upgrades) "${arguments[@]}" )
}

available_upgrades() {
  local versions name version vers versN check

  declare -A versions

  while read -r name version; do
    if is_devel $name; then
      if $devels; then
        debug "upgrade available for $colorG$name$nocolor (development package)"
        echo "$name"
      fi
    else
      versions[$name]=$version
    fi
  done < <(pacman -Qm)

  debug "found $colorG${#versions[@]}$nocolor foreign packages to check"

  while IFS='|' read -r name versN _; do
    vers="${versions[$name]}"

    read -r check < <(vercmp "$vers" "$versN")

    debug "checking $colorG$name$nocolor ($vers => $versN)"

    (( $check > 0 )) && warn "$name: local ($vers) is newer than aur ($versN)"

    if (( $check < 0 )); then
      debug "upgrade available for $colorG$name$nocolor (new version)"
      echo "$name"
    fi
  done < <(rpc_multiinfo "${!versions[@]}")
}
# }}}

# Target handling {{{
set_targets() {
  local dep="$1"; shift
  local name version

  # global: versions[]
  # global: deps[]

  (( $# )) || return

  debug "setting targets for $colorG$@$nocolor (dependency flag: $colorG$dep$nocolor)"

  while IFS='|' read -r name version _; do
    if is_ignored "$name"; then
      if ! prompt "$name is in ignore_packages. Install anyway"; then
        warn "skipping target: $name"
        continue
      fi
    fi

    versions[$name]=$version
    deps[$name]=$dep
  done < <(rpc_multiinfo "$@")
}

process_targets() {
  local name version packages

  # global: versions[]
  # global: deps[]

  for name; do
    version="${versions[$name]}"

    if [[ -n "$version" ]]; then
      packages+="${name}-$version "
    else
      die "target not found: $name"
    fi
  done

  echo -e "\n${colorY}Targets ($#):$nocolor $packages\n"

  prompt "Proceed with installation" || exit 0

  enter_build_directory

  [[ "$sync_mode" == 'install' ]] && makepkg_options+=' --install'

  for name; do
    [[ -n "${versions[$name]}" ]] && process_target "$name"
  done
}

process_target() {
  local name="$1"

  info 'Retrieving taurball from AUR...'

  if [[ "$sync_mode" == 'download' ]]; then
    debug "downloading $colorG$name$nocolor to filesystem"

    if ! taurball "$name" > "${name}.tar.gz"; then
      warn "$name: failed to retrieve aur sources"
      return 1
    fi
  else
    debug "extracting $colorG$name$nocolor directly"

    if ! taurball "$name" | tar xfz -; then
      warn "$name: failed to retrieve aur sources"
      return 1
    fi

    build_target "$name"

    discard_sources "$name"
  fi
}

build_target() {
  local name="$1" pkgbuild

  # global: deps[]

  info 'Building package...'

  debug "building $colorG$name${nocolor}..."

  cd "$name" || die 'unable to change to source directory'

  if [[ -f "/etc/customizepkg.d/$name" ]]; then
    info 'Calling customizepkg...'
    customizepkg --modify || warn "customizepkg returned non-zero ($?)"
  fi

  if prompt_to_edit "$name" 'PKGBUILD' 'building'; then
    if (( ${deps[$name]} )); then
      debug "executing $colorY$makepkg $makepkg_options --asdeps$nocolor"
      $makepkg $makepkg_options --asdeps || die "dependency package $name failed to build, aborting"
    else
      debug "executing $colorY$makepkg $makepkg_options$nocolor"
      $makepkg $makepkg_options || warn "package $name failed to build, skipping"
    fi
  fi

  cd ..

  debug "build finished"
}

discard_sources() {
  local name="$1"

  if ! $discard_sources; then
    debug "keeping sources for $colorG$name$nocolor (discard false)"
    return
  fi

  if $keep_devels && is_devel "$name"; then
    debug "keeping sources for $colorG$name$nocolor (development package)"
    return
  fi

  info 'Discarding sources...'

  debug "executing ${colorY}rm -rf ./$name$nocolor"

  rm -rf "./$name"
}
# }}}

# Help message {{{
message() {
  cat << EOF
Usage: aurget [ -h | -S* [ --options ] [ -- ] <arguments> ]

  Options:

        -S  <package>   process <package> using your default sync_mode

        -Sd <package>   download <package>
        -Sb <package>   download and build <package>
        -Sy <package>   download, build, and install <package>

        -Su             process available upgrades using your default sync_mode

        -Sdu            download available upgrades
        -Sbu            download and build available upgrades
        -Syu            download, build, and install available upgrades

        -Ss  <term>     search aur for <term>
        -Ssq <term>     search aur for <term>, print only package names
        -Sp  <package>  print the PKGBUILD for <package>
        -Si  <package>  print extended info for <package>

        --devel         only affects -Su, add all development packages

        --deps          resolve dependencies
        --nodeps        don't resolve dependencies

        --edit          prompt to edit all pkgbuilds
        --noedit        don't prompt to edit any pkgbuilds

        --discard       discard source files after building
        --nodiscard     don't discard source files after building

        --nocolor       disable coloring

        --noconfirm     auto-answer all prompts

        --ignore <package>
                        add additional packages to be ignored

        --config <file> source <file> for user configuration

        -h, --help      display this

  Any unrecognized options will be passed directly to makepkg.

EOF
}
# }}}

set_defaults "$@"

source_config

[[ ! -t 1 ]] && set_no_color

parse_options "$@"

execute_search "${arguments[@]}" && exit

add_available_upgrades

(( "${#arguments[@]}" )) || err_no_targets

set_dependencies

declare -A versions
declare -A deps

info 'Searching AUR...'
set_targets 1 "${dependencies[@]}"
set_targets 0 "${arguments[@]}"

process_targets "${dependencies[@]}" "${arguments[@]}"
